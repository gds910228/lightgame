<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Shooter</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #000;
      font-family: Arial, sans-serif;
      color: white;
      overflow: hidden;
    }
    
    #game-container {
      position: relative;
      width: 600px;
      height: 800px;
    }
    
    #game-canvas {
      background-color: #000;
      background-image: 
        radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 40px),
        radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 30px),
        radial-gradient(white, rgba(255,255,255,.1) 2px, transparent 40px);
      background-size: 550px 550px, 350px 350px, 250px 250px;
      background-position: 0 0, 40px 60px, 130px 270px;
      border: 1px solid #333;
    }
    
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 24px;
      font-weight: bold;
      color: white;
      text-shadow: 0 0 5px #0ff;
    }
    
    #health {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 24px;
      font-weight: bold;
      color: #0f0;
      text-shadow: 0 0 5px #0f0;
    }
    
    #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.8);
      z-index: 10;
    }
    
    #game-over h1 {
      font-size: 48px;
      color: red;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #f00;
    }
    
    #game-over p {
      font-size: 24px;
      margin-bottom: 30px;
    }
    
    #restart-button {
      padding: 10px 20px;
      font-size: 20px;
      background-color: #0066cc;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    #restart-button:hover {
      background-color: #0052a3;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="score">Score: 0</div>
    <div id="health">Health: 100</div>
    <canvas id="game-canvas" width="600" height="800"></canvas>
    <div id="game-over">
      <h1>GAME OVER</h1>
      <p>Your score: <span id="final-score">0</span></p>
      <button id="restart-button">Play Again</button>
    </div>
  </div>

  <script>
    // Game variables
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const healthElement = document.getElementById('health');
    const gameOverElement = document.getElementById('game-over');
    const finalScoreElement = document.getElementById('final-score');
    const restartButton = document.getElementById('restart-button');
    
    let score = 0;
    let health = 100;
    let gameOver = false;
    
    // Player variables
    const player = {
      x: canvas.width / 2,
      y: canvas.height - 100,
      width: 50,
      height: 50,
      speed: 5,
      dx: 0,
      dy: 0,
      cooldown: 0,
      fireRate: 15
    };
    
    // Arrays for game objects
    let bullets = [];
    let enemies = [];
    let enemyBullets = [];
    let particles = [];
    
    // Game settings
    const enemySpawnRate = 60; // Frames between enemy spawns
    let enemySpawnCounter = 0;
    
    // Key states
    const keys = {
      ArrowLeft: false,
      ArrowRight: false,
      ArrowUp: false,
      ArrowDown: false,
      KeyA: false,
      KeyD: false,
      KeyW: false,
      KeyS: false,
      Space: false
    };
    
    // Event listeners for keyboard input
    document.addEventListener('keydown', (e) => {
      if (keys.hasOwnProperty(e.code)) {
        keys[e.code] = true;
      }
    });
    
    document.addEventListener('keyup', (e) => {
      if (keys.hasOwnProperty(e.code)) {
        keys[e.code] = false;
      }
    });
    
    // Restart button event listener
    restartButton.addEventListener('click', restartGame);
    
    // Game initialization
    function init() {
      score = 0;
      health = 100;
      gameOver = false;
      player.x = canvas.width / 2;
      player.y = canvas.height - 100;
      bullets = [];
      enemies = [];
      enemyBullets = [];
      particles = [];
      enemySpawnCounter = 0;
      
      scoreElement.textContent = `Score: ${score}`;
      healthElement.textContent = `Health: ${health}`;
      gameOverElement.style.display = 'none';
      
      gameLoop();
    }
    
    // Game loop
    function gameLoop() {
      if (!gameOver) {
        requestAnimationFrame(gameLoop);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Update game state
        updatePlayer();
        updateBullets();
        updateEnemies();
        updateEnemyBullets();
        updateParticles();
        checkCollisions();
        
        // Draw everything
        drawPlayer();
        drawBullets();
        drawEnemies();
        drawEnemyBullets();
        drawParticles();
      }
    }
    
    // Update player position and handle shooting
    function updatePlayer() {
      // Reset velocity
      player.dx = 0;
      player.dy = 0;
      
      // Set velocity based on key states
      if ((keys.ArrowLeft || keys.KeyA) && player.x > 0) {
        player.dx = -player.speed;
      }
      if ((keys.ArrowRight || keys.KeyD) && player.x < canvas.width - player.width) {
        player.dx = player.speed;
      }
      if ((keys.ArrowUp || keys.KeyW) && player.y > 0) {
        player.dy = -player.speed;
      }
      if ((keys.ArrowDown || keys.KeyS) && player.y < canvas.height - player.height) {
        player.dy = player.speed;
      }
      
      // Update player position
      player.x += player.dx;
      player.y += player.dy;
      
      // Ensure player stays within canvas bounds
      if (player.x < 0) player.x = 0;
      if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
      if (player.y < 0) player.y = 0;
      if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
      
      // Handle shooting
      if (player.cooldown > 0) {
        player.cooldown--;
      }
      
      if (keys.Space && player.cooldown === 0) {
        bullets.push({
          x: player.x + player.width / 2 - 2,
          y: player.y,
          width: 4,
          height: 15,
          speed: 10
        });
        
        player.cooldown = player.fireRate;
      }
    }
    
    // Update bullets position
    function updateBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= bullets[i].speed;
        
        // Remove bullets that go off screen
        if (bullets[i].y < 0) {
          bullets.splice(i, 1);
        }
      }
    }
    
    // Update enemies
    function updateEnemies() {
      // Spawn new enemies
      enemySpawnCounter++;
      if (enemySpawnCounter >= enemySpawnRate) {
        enemySpawnCounter = 0;
        
        const enemy = {
          x: Math.random() * (canvas.width - 40),
          y: -50,
          width: 40,
          height: 40,
          speed: 2 + Math.random() * 2,
          health: 2,
          shootCooldown: Math.floor(Math.random() * 60) + 30
        };
        
        enemies.push(enemy);
      }
      
      // Update enemy positions and shooting
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        enemy.y += enemy.speed;
        
        // Enemy shooting
        enemy.shootCooldown--;
        if (enemy.shootCooldown <= 0) {
          enemyBullets.push({
            x: enemy.x + enemy.width / 2 - 2,
            y: enemy.y + enemy.height,
            width: 4,
            height: 15,
            speed: 5
          });
          
          enemy.shootCooldown = Math.floor(Math.random() * 60) + 60;
        }
        
        // Remove enemies that go off screen
        if (enemy.y > canvas.height) {
          enemies.splice(i, 1);
          health -= 10;
          healthElement.textContent = `Health: ${health}`;
          
          if (health <= 0) {
            endGame();
          }
        }
      }
    }
    
    // Update enemy bullets
    function updateEnemyBullets() {
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        enemyBullets[i].y += enemyBullets[i].speed;
        
        // Remove bullets that go off screen
        if (enemyBullets[i].y > canvas.height) {
          enemyBullets.splice(i, 1);
        }
      }
    }
    
    // Update particles
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.dx;
        p.y += p.dy;
        p.life--;
        
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }
    
    // Check for collisions
    function checkCollisions() {
      // Check player bullets vs enemies
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          
          if (
            bullet.x < enemy.x + enemy.width &&
            bullet.x + bullet.width > enemy.x &&
            bullet.y < enemy.y + enemy.height &&
            bullet.y + bullet.height > enemy.y
          ) {
            // Bullet hit enemy
            enemy.health--;
            
            // Create explosion particles
            createExplosion(bullet.x, bullet.y, '#ff0', 5);
            
            // Remove the bullet
            bullets.splice(i, 1);
            
            if (enemy.health <= 0) {
              // Enemy destroyed
              createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#f00', 20);
              enemies.splice(j, 1);
              score += 100;
              scoreElement.textContent = `Score: ${score}`;
            }
            
            break;
          }
        }
      }
      
      // Check enemy bullets vs player
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const bullet = enemyBullets[i];
        
        if (
          bullet.x < player.x + player.width &&
          bullet.x + bullet.width > player.x &&
          bullet.y < player.y + player.height &&
          bullet.y + bullet.height > player.y
        ) {
          // Bullet hit player
          enemyBullets.splice(i, 1);
          health -= 10;
          healthElement.textContent = `Health: ${health}`;
          
          // Create explosion particles
          createExplosion(bullet.x, bullet.y, '#0ff', 10);
          
          if (health <= 0) {
            endGame();
          }
        }
      }
      
      // Check enemies vs player (collision)
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        
        if (
          player.x < enemy.x + enemy.width &&
          player.x + player.width > enemy.x &&
          player.y < enemy.y + enemy.height &&
          player.y + player.height > enemy.y
        ) {
          // Enemy collided with player
          enemies.splice(i, 1);
          health -= 20;
          healthElement.textContent = `Health: ${health}`;
          
          // Create explosion particles
          createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#f00', 20);
          
          if (health <= 0) {
            endGame();
          }
        }
      }
    }
    
    // Create explosion particles
    function createExplosion(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3 + 1;
        
        particles.push({
          x: x,
          y: y,
          size: Math.random() * 3 + 1,
          dx: Math.cos(angle) * speed,
          dy: Math.sin(angle) * speed,
          color: color,
          life: Math.floor(Math.random() * 30) + 10
        });
      }
    }
    
    // Draw player
    function drawPlayer() {
      ctx.fillStyle = '#0ff';
      
      // Draw ship body
      ctx.beginPath();
      ctx.moveTo(player.x + player.width / 2, player.y);
      ctx.lineTo(player.x + player.width, player.y + player.height);
      ctx.lineTo(player.x, player.y + player.height);
      ctx.closePath();
      ctx.fill();
      
      // Draw ship engines
      ctx.fillStyle = '#ff0';
      ctx.fillRect(player.x + 10, player.y + player.height, 10, 5);
      ctx.fillRect(player.x + player.width - 20, player.y + player.height, 10, 5);
    }
    
    // Draw bullets
    function drawBullets() {
      ctx.fillStyle = '#0ff';
      bullets.forEach(bullet => {
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
      });
    }
    
    // Draw enemies
    function drawEnemies() {
      ctx.fillStyle = '#f00';
      enemies.forEach(enemy => {
        // Draw enemy ship
        ctx.beginPath();
        ctx.moveTo(enemy.x + enemy.width / 2, enemy.y + enemy.height);
        ctx.lineTo(enemy.x + enemy.width, enemy.y);
        ctx.lineTo(enemy.x, enemy.y);
        ctx.closePath();
        ctx.fill();
      });
    }
    
    // Draw enemy bullets
    function drawEnemyBullets() {
      ctx.fillStyle = '#f00';
      enemyBullets.forEach(bullet => {
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
      });
    }
    
    // Draw particles
    function drawParticles() {
      particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
      });
    }
    
    // End game
    function endGame() {
      gameOver = true;
      finalScoreElement.textContent = score;
      gameOverElement.style.display = 'flex';
    }
    
    // Restart game
    function restartGame() {
      init();
    }
    
    // Start the game
    init();
  </script>
</body>
</html> 