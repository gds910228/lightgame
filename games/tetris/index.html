<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris Game</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    
    #game-container {
      position: relative;
      width: 300px;
      margin: 0 auto;
    }
    
    #tetris-canvas {
      border: 2px solid #333;
      background-color: #111;
    }
    
    #next-piece-canvas {
      border: 2px solid #333;
      background-color: #111;
      margin-top: 10px;
    }
    
    #game-info {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }
    
    .info-box {
      background-color: #333;
      color: white;
      padding: 10px;
      border-radius: 5px;
      width: 45%;
      text-align: center;
    }
    
    #error-message {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255, 0, 0, 0.1);
      padding: 20px;
      border-radius: 5px;
      color: #ff0000;
      text-align: center;
      z-index: 100;
    }
    
    #debug-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: #fff;
      font-size: 12px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 5px;
      border-radius: 3px;
      max-width: 280px;
      word-wrap: break-word;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="tetris-canvas" width="240" height="400"></canvas>
    <div id="game-info">
      <div class="info-box">Score: <span id="score">0</span></div>
      <div class="info-box">Level: <span id="level">1</span></div>
    </div>
    <canvas id="next-piece-canvas" width="100" height="100"></canvas>
    <div id="error-message"></div>
    <div id="debug-info">初始化中...</div>
  </div>

  <script>
    // 添加调试信息
    const debugInfo = document.getElementById('debug-info');
    function updateDebugInfo(message) {
      if (debugInfo) {
        debugInfo.textContent = message;
      }
      console.log(message);
    }
    
    updateDebugInfo("游戏开始加载...");
    
    // 记录环境信息
    updateDebugInfo(`环境: ${window.location.hostname}, 路径: ${window.location.pathname}`);
    
    // Error handling function
    function handleError(message) {
      const errorElement = document.getElementById('error-message');
      errorElement.textContent = `Error: ${message}. Please try refreshing the page.`;
      errorElement.style.display = 'block';
      updateDebugInfo(`错误: ${message}`);
      console.error(message);
    }

    try {
      updateDebugInfo("获取Canvas元素...");
      // Get canvas elements
      const canvas = document.getElementById('tetris-canvas');
      const nextPieceCanvas = document.getElementById('next-piece-canvas');
      
      if (!canvas || !nextPieceCanvas) {
        throw new Error('Canvas elements not found');
      }
      
      const ctx = canvas.getContext('2d');
      const nextPieceCtx = nextPieceCanvas.getContext('2d');
      
      if (!ctx || !nextPieceCtx) {
        throw new Error('Could not get canvas context');
      }
      
      updateDebugInfo("初始化游戏变量...");
      
      // Game constants
      const ROWS = 20;
      const COLS = 12;
      const BLOCK_SIZE = canvas.width / COLS;
      const EMPTY = '#111';
      
      // Tetromino colors
      const COLORS = [
        '#000000',
        '#FF0000', // Red
        '#00FF00', // Green
        '#0000FF', // Blue
        '#FFFF00', // Yellow
        '#00FFFF', // Cyan
        '#FF00FF', // Magenta
        '#FF7F00'  // Orange
      ];
      
      // Tetromino shapes
      const SHAPES = [
        [],
        [[1, 1, 1, 1]],                 // I
        [[1, 1, 1], [0, 1, 0]],         // T
        [[1, 1], [1, 1]],               // O
        [[1, 1, 0], [0, 1, 1]],         // Z
        [[0, 1, 1], [1, 1, 0]],         // S
        [[1, 1, 1], [1, 0, 0]],         // L
        [[1, 1, 1], [0, 0, 1]]          // J
      ];
      
      // Game variables
      let board = [];
      let score = 0;
      let level = 1;
      let gameOver = false;
      let dropInterval = 1000; // milliseconds
      let lastDropTime = 0;
      let currentPiece = null;
      let nextPiece = null;
      
      // DOM elements
      const scoreElement = document.getElementById('score');
      const levelElement = document.getElementById('level');
      
      // Initialize the board
      function initBoard() {
        for (let r = 0; r < ROWS; r++) {
          board[r] = [];
          for (let c = 0; c < COLS; c++) {
            board[r][c] = EMPTY;
          }
        }
      }
      
      // Draw a square
      function drawSquare(ctx, x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        
        if (color !== EMPTY) {
          ctx.strokeStyle = '#FFF';
          ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          
          // Add 3D effect
          ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
          ctx.beginPath();
          ctx.moveTo(x * BLOCK_SIZE, y * BLOCK_SIZE);
          ctx.lineTo((x + 1) * BLOCK_SIZE, y * BLOCK_SIZE);
          ctx.lineTo(x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE);
          ctx.fill();
          
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.beginPath();
          ctx.moveTo((x + 1) * BLOCK_SIZE, y * BLOCK_SIZE);
          ctx.lineTo((x + 1) * BLOCK_SIZE, (y + 1) * BLOCK_SIZE);
          ctx.lineTo(x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE);
          ctx.fill();
        }
      }
      
      // Draw the board
      function drawBoard() {
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            drawSquare(ctx, c, r, board[r][c]);
          }
        }
      }
      
      // The Piece object
      class Piece {
        constructor(shape, color) {
          this.shape = shape;
          this.color = color;
          this.row = -2;
          this.col = Math.floor(COLS / 2) - Math.floor(shape[0].length / 2);
          this.rotation = 0;
        }
        
        // Draw the piece
        draw() {
          for (let r = 0; r < this.shape.length; r++) {
            for (let c = 0; c < this.shape[r].length; c++) {
              if (this.shape[r][c]) {
                drawSquare(ctx, this.col + c, this.row + r, this.color);
              }
            }
          }
        }
        
        // Undraw the piece
        undraw() {
          for (let r = 0; r < this.shape.length; r++) {
            for (let c = 0; c < this.shape[r].length; c++) {
              if (this.shape[r][c]) {
                drawSquare(ctx, this.col + c, this.row + r, EMPTY);
              }
            }
          }
        }
        
        // Move down
        moveDown() {
          if (!this.collision(0, 1)) {
            this.undraw();
            this.row++;
            this.draw();
            return true;
          }
          this.lock();
          
          // 只有在当前方块锁定后才生成新方块
          if (!gameOver) {
            currentPiece = nextPiece;
            nextPiece = randomPiece();
            drawNextPiece();
            
            // 只有在新方块生成后发生碰撞才判定游戏结束
            if (currentPiece.collision(0, 0)) {
              // Game over
              gameOver = true;
              alert(`Game Over! Your score: ${score}`);
              resetGame();
            }
          }
          
          return false;
        }
        
        // Move right
        moveRight() {
          if (!this.collision(1, 0)) {
            this.undraw();
            this.col++;
            this.draw();
          }
        }
        
        // Move left
        moveLeft() {
          if (!this.collision(-1, 0)) {
            this.undraw();
            this.col--;
            this.draw();
          }
        }
        
        // Rotate
        rotate() {
          const nextPattern = this.rotateShape();
          let kick = 0;
          
          // Check if rotation puts piece outside the board
          if (this.col < 0) {
            kick = 0 - this.col;
          } else if (this.col + nextPattern[0].length > COLS) {
            kick = COLS - (this.col + nextPattern[0].length);
          }
          
          // Apply the rotation
          this.undraw();
          this.col += kick;
          this.shape = nextPattern;
          this.draw();
        }
        
        // Rotate the shape
        rotateShape() {
          const result = [];
          const n = this.shape.length;
          const m = this.shape[0].length;
          
          for (let i = 0; i < m; i++) {
            result[i] = [];
            for (let j = 0; j < n; j++) {
              result[i][j] = this.shape[n - 1 - j][i];
            }
          }
          
          return result;
        }
        
        // Check collision
        collision(x, y) {
          for (let r = 0; r < this.shape.length; r++) {
            for (let c = 0; c < this.shape[r].length; c++) {
              if (!this.shape[r][c]) {
                continue;
              }
              
              const newRow = this.row + r + y;
              const newCol = this.col + c + x;
              
              // 检查是否超出左右边界或底部
              if (newCol < 0 || newCol >= COLS || newRow >= ROWS) {
                return true;
              }
              
              // 如果方块在屏幕顶部以上，跳过碰撞检测
              if (newRow < 0) {
                continue;
              }
              
              // 检查是否与已有方块碰撞
              if (board[newRow][newCol] !== EMPTY) {
                return true;
              }
            }
          }
          return false;
        }
        
        // Lock the piece
        lock() {
          for (let r = 0; r < this.shape.length; r++) {
            for (let c = 0; c < this.shape[r].length; c++) {
              if (!this.shape[r][c]) {
                continue;
              }
              
              // Game over if piece locks above the board
              if (this.row + r < 0) {
                gameOver = true;
                return;
              }
              
              board[this.row + r][this.col + c] = this.color;
            }
          }
          
          // Check for completed rows
          let linesCleared = 0;
          for (let r = 0; r < ROWS; r++) {
            let isRowFull = true;
            for (let c = 0; c < COLS; c++) {
              if (board[r][c] === EMPTY) {
                isRowFull = false;
                break;
              }
            }
            
            if (isRowFull) {
              // Move all rows above down
              for (let y = r; y > 0; y--) {
                for (let c = 0; c < COLS; c++) {
                  board[y][c] = board[y-1][c];
                }
              }
              
              // Clear the top row
              for (let c = 0; c < COLS; c++) {
                board[0][c] = EMPTY;
              }
              
              linesCleared++;
            }
          }
          
          // Update score and level
          if (linesCleared > 0) {
            score += linesCleared * linesCleared * 100 * level;
            scoreElement.textContent = score;
            
            // Increase level every 10 lines
            if (score >= level * 1000) {
              level++;
              levelElement.textContent = level;
              dropInterval = Math.max(100, 1000 - (level - 1) * 100);
            }
          }
        }
        
        // Hard drop
        hardDrop() {
          while (this.moveDown()) {
            // Keep moving down
          }
        }
      }
      
      // Generate a random piece
      function randomPiece() {
        const randomIndex = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
        return new Piece(SHAPES[randomIndex], COLORS[randomIndex]);
      }
      
      // Draw the next piece
      function drawNextPiece() {
        // Clear the next piece canvas
        nextPieceCtx.fillStyle = EMPTY;
        nextPieceCtx.fillRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
        
        // Calculate the center position
        const blockSize = 20;
        const offsetX = (nextPieceCanvas.width - nextPiece.shape[0].length * blockSize) / 2;
        const offsetY = (nextPieceCanvas.height - nextPiece.shape.length * blockSize) / 2;
        
        // Draw the next piece
        for (let r = 0; r < nextPiece.shape.length; r++) {
          for (let c = 0; c < nextPiece.shape[r].length; c++) {
            if (nextPiece.shape[r][c]) {
              // Draw the square
              nextPieceCtx.fillStyle = nextPiece.color;
              nextPieceCtx.fillRect(offsetX + c * blockSize, offsetY + r * blockSize, blockSize, blockSize);
              
              // Draw the border
              nextPieceCtx.strokeStyle = '#FFF';
              nextPieceCtx.strokeRect(offsetX + c * blockSize, offsetY + r * blockSize, blockSize, blockSize);
              
              // Add 3D effect
              nextPieceCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
              nextPieceCtx.beginPath();
              nextPieceCtx.moveTo(offsetX + c * blockSize, offsetY + r * blockSize);
              nextPieceCtx.lineTo(offsetX + (c + 1) * blockSize, offsetY + r * blockSize);
              nextPieceCtx.lineTo(offsetX + c * blockSize, offsetY + (r + 1) * blockSize);
              nextPieceCtx.fill();
              
              nextPieceCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
              nextPieceCtx.beginPath();
              nextPieceCtx.moveTo(offsetX + (c + 1) * blockSize, offsetY + r * blockSize);
              nextPieceCtx.lineTo(offsetX + (c + 1) * blockSize, offsetY + (r + 1) * blockSize);
              nextPieceCtx.lineTo(offsetX + c * blockSize, offsetY + (r + 1) * blockSize);
              nextPieceCtx.fill();
            }
          }
        }
      }
      
      // Reset the game
      function resetGame() {
        initBoard();
        score = 0;
        level = 1;
        gameOver = false;
        dropInterval = 1000;
        scoreElement.textContent = score;
        levelElement.textContent = level;
        
        currentPiece = randomPiece();
        nextPiece = randomPiece();
        drawNextPiece();
      }
      
      // Game loop
      function gameLoop(timestamp) {
        if (!lastDropTime) lastDropTime = timestamp;
        const deltaTime = timestamp - lastDropTime;
        
        if (deltaTime > dropInterval) {
          currentPiece.moveDown();
          lastDropTime = timestamp;
        }
        
        if (!gameOver) {
          drawBoard();
          currentPiece.draw();
          requestAnimationFrame(gameLoop);
        }
      }
      
      // Handle keyboard events
      document.addEventListener('keydown', function(e) {
        if (gameOver) return;
        
        switch (e.key) {
          case 'ArrowLeft':
            currentPiece.moveLeft();
            break;
          case 'ArrowRight':
            currentPiece.moveRight();
            break;
          case 'ArrowDown':
            currentPiece.moveDown();
            break;
          case 'ArrowUp':
            currentPiece.rotate();
            break;
          case ' ':
            currentPiece.hardDrop();
            break;
        }
      });
      
      // Initialize and start the game
      initBoard();
      currentPiece = randomPiece();
      nextPiece = randomPiece();
      drawNextPiece();
      requestAnimationFrame(gameLoop);
    } catch (error) {
      handleError(error.message || 'Unknown error occurred');
    }
  </script>
</body>
</html> 